# 图遍历
## 1.深度遍历（DFS）
    图的遍历和树的遍历类似
### 节点遍历（visited一维数组辅助）
```java
//遍历过的节点标记，解决图成环导致的死循环
boolean[] visited;
void traverser(Graph graph, int s, boolean[] visited){
    if(visited[s]){
        return;
    }
    //前序位置
    visited[s] = true;
    System.out.println("visit " + s);
    for (Edge e : graph.neighbors(s)) {
        traverse(graph, e.to, visited);
    }
    //后序位置
}
```
### 边遍历（visited二维数组辅助）
```java
//遍历过的边标记，解决图成环导致的死循环,这里是二维的，两个点组成一条边
boolean[][] visited;
void traverser(Graph graph, int s, boolean[][] visited){
    //前序位置
    for (Edge e : graph.neighbors(s)) {
        if(visited[s][e.to]){
            continue;
        }
        //访问并标记
        visited[s][e.to] = true;
        System.out.println("visit " + s + "--" + e.to);
        traverse(graph, e.to, visited);
    }
    //后序位置
}
```

### 路径遍历（onPath数组辅助）
```java
// 下面的算法代码可以遍历图的所有路径，寻找从 src 到 dest 的所有路径
//onPath和visited作用类似，只不过找路径可以重复过一个点，所以在后序位置要移除访问标记。
boolean[] onPath = new boolean[graph.size()];
List<Integer> path = new LinkedList<>();

void traverser(Graph graph, int src,int dest){
    
    //防止成环
    if (onPath[src]) {
        return;
    }
    if (src == dest){
        // 找到目标节点
        System.out.println("find path: " + String.join("->", path) + "->" + dest);
        return;
    }
    //前序位置
    onPath[src] = true;
    path.add(src);
    for (Edge e : graph.neighbors(src)) {
        traverse(graph, e.to, dest);
    }
    //后序位置
    path.removeLast();
    onPath[src] = false;
}
```

    上面借助visited和onPath都是用来解决成环问题，如果题目已经告诉你了不成环，这就需要辅助数组了
例题：

[797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/description/) 找到n-1的路径，标准图深度路径遍历。

## 2.广度遍历（BFS）

