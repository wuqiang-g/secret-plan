# 图遍历
## 1.深度遍历（DFS）
    图的遍历和树的遍历类似
### 节点遍历（visited一维数组辅助）
```java
//遍历过的节点标记，解决图成环导致的死循环
boolean[] visited;
void traverser(Graph graph, int s, boolean[] visited){
    if(visited[s]){
        return;
    }
    //前序位置
    visited[s] = true;
    System.out.println("visit " + s);
    for (Edge e : graph.neighbors(s)) {
        traverse(graph, e.to, visited);
    }
    //后序位置
}
```
### 边遍历（visited二维数组辅助）
```java
//遍历过的边标记，解决图成环导致的死循环,这里是二维的，两个点组成一条边
boolean[][] visited;
void traverser(Graph graph, int s, boolean[][] visited){
    //前序位置
    for (Edge e : graph.neighbors(s)) {
        if(visited[s][e.to]){
            continue;
        }
        //访问并标记
        visited[s][e.to] = true;
        System.out.println("visit " + s + "--" + e.to);
        traverse(graph, e.to, visited);
    }
    //后序位置
}
```

### 路径遍历（onPath数组辅助）
```java
// 下面的算法代码可以遍历图的所有路径，寻找从 src 到 dest 的所有路径
//onPath和visited作用类似，只不过找路径可以重复过一个点，所以在后序位置要移除访问标记。
boolean[] onPath = new boolean[graph.size()];
List<Integer> path = new LinkedList<>();

void traverser(Graph graph, int src,int dest){
    
    //防止成环
    if (onPath[src]) {
        return;
    }
    if (src == dest){
        // 找到目标节点
        System.out.println("find path: " + String.join("->", path) + "->" + dest);
        return;
    }
    //前序位置
    onPath[src] = true;
    path.add(src);
    for (Edge e : graph.neighbors(src)) {
        traverse(graph, e.to, dest);
    }
    //后序位置
    path.removeLast();
    onPath[src] = false;
}
```

    上面借助visited和onPath都是用来解决成环问题，如果题目已经告诉你了不成环，这就需要辅助数组了
例题：

[797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/description/) 找到n-1的路径，标准图深度路径遍历。

## 2.广度遍历（BFS）
    
    广度遍历也和多叉树的广度遍历类似，用队列来辅助
    广度遍历一般只用来求最短路径，也就是遍历节点。
    按照 BFS 算法一层一层向四周扩散的逻辑，第一次遇到目标节点，必然就是最短路径

### 方法一（不记录步数）
```java
//从节点s开始遍历
void bfs(Graph graph, int s) {
    boolean[] visited = new boolean[graph.size()];
    Queue<Integer> q = new LinkedList<>();
    
    q.offer(s);
    visited[s] = true;
    
    while (!q.isEmpty()){
        int cur = q.poll();
        System.out.println("visit " + cur);
        
        for(Edge e : graph.neighbors(cur)){
            if(visited[e.to]){
                continue;
            }
            q.offer(e.to);
            visited[e.to] = true;
        }
    }
    
}

```

### 方法二（记录步数）
```java
//从节点s开始遍历
void bfs(Graph graph, int s) {
    boolean[] visited = new boolean[graph.size()];
    Queue<Integer> q = new LinkedList<>();
    
    q.offer(s);
    visited[s] = true;
    //记录从 s 开始走到当前节点的步数
    int step = 0;
    while (!q.isEmpty()){
        //一进来就记录这一层的数量
        int size = q.size();
        for(int i = 0 ; i < size ; i++){
            int cur = q.poll();
            System.out.println("visit " + cur);

            for(Edge e : graph.neighbors(cur)){
                if(visited[e.to]){
                    continue;
                }
                q.offer(e.to);
                visited[e.to] = true;
            }
        }
        step++;
    }
    
}
```

### 方法三（记录边权重）
```java
// 图结构的 BFS 遍历，从节点 s 开始进行 BFS，且记录遍历步数（从起点 s 到当前节点的边的条数）
// 每个节点自行维护 State 类，记录从 s 走来的遍历步数
class State {
    // 当前节点 ID
    int node;
    // 从起点 s 到当前节点的遍历步数
    int step;

    public State(int node, int step) {
        this.node = node;
        this.step = step;
    }
}

void bfs(Graph graph, int s) {
    boolean[] visited = new boolean[graph.size()];
    Queue<State> q = new LinkedList<>();

    q.offer(new State(s,0));
    visited[s] = true;

    while (!q.isEmpty()){
        State state = q.poll();
        System.out.println("visit " + cur.node);
        int cur = state.node;
        int step = state.step;
        for(Edge e : graph.neighbors(cur)){
            if(visited[e.to]){
                continue;
            }
            q.offer(new State(e.to,step+1));
            visited[e.to] = true;
        }
    }

}

```

