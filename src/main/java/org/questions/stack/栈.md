# 栈
    后进先出
    push(x)：将元素 x 压入栈中
    pop()：弹出栈顶元素
    peek()：获取栈顶元素

--- 
## [一、栈习题](https://labuladong.online/algo/problem-set/stack/)

    这种特性，常见算法图：表达式运算、括号合法性检测 等

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/) 遇见左括号就压栈，右括号就弹出栈顶括号比对，不一致或者为空则不合法。

[71. 简化路径](https://leetcode.cn/problems/simplify-path/description/) 题目有点绕，但是就是按/分割路径，子串为空或者.跳过、..两个点则弹栈(模拟返回)，其他情况则入栈。最后再依次出栈拼接结果。

[143. 重排链表](https://leetcode.cn/problems/reorder-list/description/) 按头尾头尾的顺序重排，用栈来反着遍历指针。但是要注意合并的链表的解决条件。

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

[388. 文件的最长绝对路径](https://leetcode.cn/problems/longest-absolute-file-path/description/)

[155. 最小栈](https://leetcode.cn/problems/min-stack/description/)

[895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/submissions/)

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/)

---

## [二、单调栈](https://labuladong.online/algo/data-structure/monotonic-stack/)
    单调栈，解决当前元素下一个最值问题

    public static  int[] calculateGreaterElement(int[] nums) {
        int[] res = new int[nums.length];
        Stack<Integer> stk = new Stack<>();
        //从后往前遍历
        for(int i = nums.length -1 ; i >= 0 ;i --){
            //如果栈顶小，则出栈（栈出顺序就是当前元素后面的元素顺序。）
            while(!stk.isEmpty() && stk.peek() <= nums[i]){
                //这里其实在找下一个最值
                stk.pop();
            }
            //为空则代表后面没有比他大的值
            res[i] = stk.isEmpty() ? -1 : stk.peek();
            //处理完，当前原始压栈，供当前元素前面的元素找最值
            stk.push(nums[i]);
        }
        return res;
    }

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/description/) 直接先单调栈找下一个最大值模版得到nums2的下一个最值，然后nums1找nums2对应的值对应的下一个最大值

[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)

---
## [三、单调栈变种]()

[]()

[]()

[]()