# 栈
    后进先出
    push(x)：将元素 x 压入栈中
    pop()：弹出栈顶元素
    peek()：获取栈顶元素

--- 
## [一、栈习题](https://labuladong.online/algo/problem-set/stack/)

    这种特性，常见算法图：表达式运算、括号合法性检测 等

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/) 遇见左括号就压栈，右括号就弹出栈顶括号比对，不一致或者为空则不合法。

[71. 简化路径](https://leetcode.cn/problems/simplify-path/description/) 题目有点绕，但是就是按/分割路径，子串为空或者.跳过、..两个点则弹栈(模拟返回)，其他情况则入栈。最后再依次出栈拼接结果。

[143. 重排链表](https://leetcode.cn/problems/reorder-list/description/) 按头尾头尾的顺序重排，用栈来反着遍历指针。但是要注意合并的链表的解决条件。

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

[388. 文件的最长绝对路径](https://leetcode.cn/problems/longest-absolute-file-path/description/)

[155. 最小栈](https://leetcode.cn/problems/min-stack/description/)

[895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/submissions/)

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/)

---

## [二、单调栈](https://labuladong.online/algo/data-structure/monotonic-stack/)
    单调栈，解决当前元素下一个最值问题

    public static  int[] calculateGreaterElement(int[] nums) {
        int[] res = new int[nums.length];
        Stack<Integer> stk = new Stack<>();
        //从后往前遍历
        for(int i = nums.length -1 ; i >= 0 ;i --){
            //如果栈顶小，则出栈（栈出顺序就是当前元素后面的元素顺序。）
            while(!stk.isEmpty() && stk.peek() <= nums[i]){
                //这里其实在找下一个最值
                stk.pop();
            }
            //为空则代表后面没有比他大的值
            res[i] = stk.isEmpty() ? -1 : stk.peek();
            //处理完，当前原始压栈，供当前元素前面的元素找最值
            stk.push(nums[i]);
        }
        return res;
    }

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/description/) 直接先单调栈找下一个最大值模版得到nums2的下一个最值，然后nums1找nums2对应的值对应的下一个最大值

[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/) 找环形数组下一个最大元素，数组长度模拟翻倍，实际下标是求余后的原数组下标，这样环形找下一个最大值。

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/) 本质上是找下一个最大原始，只不过找到是下标，所以单调栈里面存下标

---
## [三、单调栈变体及习题](https://labuladong.online/algo/problem-set/monotonic-stack/)

    变体：下一个更小的元素，还是反向遍历，判断条件变了；上一个最值元素，这个就是顺序遍历然后压栈弹栈即可。

[1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/description/) 链表变数组，单调栈

[1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/description/) 计算到下一个最大值之间的距离，单调栈

[1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/) 计算下一个最小值，单调栈变种

[901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/description/)前一个最大值，但是要记录一下当前值弹出时，当前值前面的弹出数量,方便后面用。

[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/description/)边删除边维护一个单调增栈（注意栈为空，且当前=0，要跳过防止头部为0），如果k还大于0，则弹栈删除后面元素。最后弹栈再反转输出结果。

[853. 车队](https://leetcode.cn/problems/car-fleet/description/) 规律，位置后的车反而快，则被位置前单是慢的车卡住，先按位置排序，再计算速度，看有几递增子序列，就有几个车队(正序递减栈大小就是车队数)

[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/) 正序，维护单调增栈，弹掉的就是乱序的，弹掉的最小索引就是左边界；逆序，维护单调递减栈，弹掉乱序，弹掉的最大索引就是右边界。