# 二分搜索
    解决：有序数组找有效值 ; 找有效最大or最小值。

---
    技巧：
    [left,right]理解左右指针的开闭，如果是闭，则重新给左右指针赋值就需要mid加减1。
    同时要根据开闭，来确保while的结束，如果闭[left,right] 则while(left <= right) while结束是left > right
### 二分搜索三种方法（找有效值，找有效最左值，找有效最右值）

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        //为了整型不溢出，一般用加上区间一半的方式(right - left) / 2
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    //因为有序，先边界判断一下
    if(nums.length == 0 || target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    //因为有序，先边界判断一下
    if(nums.length == 0 || target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后判断一下 nums[right] 是不是 target
    return nums[right] == target ? right : -1;
}
```

例题：

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/) 标准二分查找

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/) 标准二分查找有效最值

### 二分搜索运用
    泛化技巧：
    1. 抽象题目找到一个f(x)函数，函数是单调减or增函数，x是要求的值
    2. target是给定的值,target是啥含义，f(x)就是啥含义 找到f(x) = targert x的最小值或者最大值
    3. 还有就是x的left 和 right得根据题目边界设定
---
例题：

[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/description/) 标准二分查找有效最值，求速度，则x就是速度，要和时间h比,f(x)就代表时间，代表以x为速度，吃完所有香蕉所需要的时间。

[1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/) 标准二分查找有效最值，求装载量，则x就是装载量，要和天数d比，则f(x)就代表装载能力为x时，装完所需的天数，稍微注意下f(x)的边界问题。

[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/description/) 其实就是1011一样的题,x代表装载量(当前方式分割后，子数组和的最大值就是这种分割方式的装载量)，f(x)代表装完所需的天数。