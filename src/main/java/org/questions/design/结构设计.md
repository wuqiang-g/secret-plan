# 数据结构设计

## [LRU算法](https://labuladong.online/algo/data-structure/lru-cache/)

    最近使用的在最前面，get put O(1)时间复杂的，LinkedHashMap实现
    get put 都需要把元素提到前面，超过大小，把最早的去掉。


习题：

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

----

## [LRU算法](https://labuladong.online/algo/frequency-interview/lfu/)

    也是LinkedHash实现，使用频率最多的在最前面，使用频率相同，则淘汰时间早的
    比较复杂 需要维护 
    HashMap kv 表
    HashMap keyAndFreq kf表
    HashMao<？,LinkedHashSet<>> freqMapKeys fk表
    int minFreq 当前最小频次.
    
习题：

[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/description/)

---

## [更多结构设计题](https://labuladong.online/algo/problem-set/ds-design/)

[729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/description/) 利用treeMap kv(存储start,end) 利用floorKey ceilingKey 判断是否有重叠。

[950. 按递增顺序显示卡牌](https://leetcode.cn/problems/reveal-cards-in-increasing-order/description/) 逆序还原：【数组1】题目先减少头部，再头部移入尾部，减少的得到一个数组【数组2】那我数组2反过来，先尾部移入头部，再往头部加，加出来的就是数组[1]

[1700. 无法吃午餐的学生数量](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/description/) 先统计两种类型的学生人数，栈顶的类型，剩下的学生里没有喜欢吃，则得到结果。

[55. 最小栈](https://leetcode.cn/problems/min-stack/description/) 空间换时间，再搞一个min栈，保存当前栈内的最新值。

[1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/description/) 队列设计题里面有。

[895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/description/) 优先类似LFU算法，维护valMapFeq,freqMapValStack。

[284. 窥视迭代器](https://leetcode.cn/problems/peeking-iterator/description/) 直接维护一个nextElem变量

---